
<h2>满二叉树</h2>

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

<h2>完全二叉树</h2>

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，

并且最下面一层的节点都集中在该层最左边的若干位置。

若最底层为第 h 层，则该层包含 1 ~ 2^h -1  个节点。

<h2>二叉搜索树</h2>

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

<h2>平衡二叉搜索树</h2>

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，

且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

------------------

<h2>存储方式</h2>

顺序存储和链式存储

- 顺序存储：用数组存储, 遍历：如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。
- 链式存储: 用指针, 链式存储更有利于理解。

------------------

<h2>遍历方式</h2>

深度优先和广度优先

- 深度优先: 往深了走，遇到子节点再回头
    - 前序遍历
    - 中序遍历
    - 后序遍历

- 广度优先: 一层一层遍历
    - 层序遍历

------------------

<h2>二叉树节点的定义</h2>

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int value, TreeNode *left=nullptr, TreeNode *right=nullptr) : val(value) {}
};
```

------------------

<h2>递归怎么写?</h2>

每次写递归都是碰运气写对，递归到底怎么写？

递归三部曲：

- 确定递归的参数和返回值: 确定哪些参数是递归过程中需要处理的，就在递归函数中加上这些参数，并且还要明确每次递归的返回值是什么从而确定返回值的类型
- 确定终止条件：终止条件没有写或者写的不多，必将造成内存栈的溢出
- 确定单层递归的逻辑：确定每一层递归需要处理的信息

------------------

<a href="144.cpp">144. 二叉树的前序遍历</a>

<a href="145.cpp">145. 二叉树的后序遍历</a>

<a href="94.cpp">94. 二叉树的中序遍历</a>
